#include "jni.h"
#include <sys/stat.h>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <sys/ptrace.h>

#include <unistd.h>
#include <dlfcn.h>
#include <android/log.h>

#include <elf.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/shm.h>

#include "include/inlineHook.h"
#include "include/dlfcn_compat.h"
#include "include/dlfcn_nougat.h"


#define LOG_TAG "Stub"
#define LOGD(fmt,args...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG,fmt, ##args)
void *(*oriloadmethod)(void *, void *, void *, void *, void *);
void* *(*oriexecve)(const char *file, char *const *argv, char *const *envp);

jobject gcontext = nullptr;
JNIEnv *genv = nullptr;
char *path =(char*) malloc(sizeof(char) * 100);

typedef unsigned char byte;
byte* methodAddr = nullptr;

const char sign[] = {
        0x33,0x31,0x3a,0x31,0x34,0x36,0x34,0x61,0x3b,0x39,0x32,0x39,0x3c,0x3f,0x3f,0x38,0x71,0x21,0x22,0x20,0x24,0x27,0x26,0x26,0x28,0x2b,0x2a,0x29,0x2c,0x29,0x29,0x2d,0x44,0x43,0x1b,0x47,0x16,0x15,0x15,0x17,0x18,0x4d,0x1a,0x36,0x31,0x3b,0x31,0x65,0x3d,0x30,0x33,0x30,0x31,0x3c,0x6d,0x3b,0x3d,0x6a,0x3f,0x21,0x21,0x23,0x23,0x76,0x25,0x23,0x27,0x28,0x2a,0x2a,0x2f,0x24,0x2e,0x2f,0x2f,0x41,0x12,0x12,0x13,0x1c,0x15,0x10,0x17,0x1b,0x1c,0x1f,0x30,0x35,0x32,0x35,0x35,0x36,0x36,0x36,0x3f,0x3a,0x39,0x3a,0x3c,0x6c,0x3d,0x3f,0x20,0x29,0x22,0x25,0x24,0x26,0x23,0x22,0x28,0x2d,0x2a,0x23,0x2d,0x2e,0x2e,0x2e,0x17,0x12,0x11,0x12,0x14,0x44,0x15,0x17,0x18,0x11,0x1a,0x36,0x31,0x31,0x36,0x31,0x35,0x32,0x37,0x3f,0x38,0x39,0x3b,0x3d,0x3a,0x3d,0x3c,0x21,0x21,0x73,0x20,0x24,0x25,0x2e,0x27,0x2e,0x29,0x29,0x2e,0x29,0x2d,0x2a,0x2f,0x41,0x10,0x11,0x13,0x15,0x12,0x15,0x14,0x19,0x19,0x4b,0x33,0x31,0x32,0x3b,0x34,0x33,0x36,0x34,0x3d,0x3c,0x3a,0x3f,0x3c,0x6f,0x3f,0x3c,0x20,0x20,0x25,0x20,0x27,0x24,0x26,0x76,0x2b,0x29,0x2a,0x23,0x2c,0x2b,0x2e,0x2c,0x15,0x14,0x12,0x17,0x14,0x16,0x17,0x14,0x18,0x18,0x1d,0x33,0x32,0x32,0x32,0x61,0x34,0x31,0x37,0x6c,0x3a,0x38,0x38,0x3d,0x3e,0x3e,0x3c,0x25,0x22,0x23,0x20,0x27,0x26,0x26,0x24,0x2a,0x2a,0x2b,0x28,0x25,0x2e,0x2d,0x2c,0x10,0x14,0x43,0x12,0x13,0x15,0x42,0x14,0x1c,0x1a,0x1c,0x33,0x31,0x31,0x36,0x37,0x35,0x35,0x30,0x3b,0x39,0x39,0x39,0x3f,0x3c,0x3d,0x36,0x23,0x22,0x21,0x23,0x21,0x74,0x25,0x27,0x2c,0x21,0x29,0x2a,0x2c,0x7c,0x2d,0x2f,0x10,0x19,0x12,0x15,0x14,0x16,0x13,0x12,0x18,0x1d,0x1a,0x36,0x30,0x31,0x33,0x35,0x32,0x35,0x34,0x39,0x39,0x6b,0x38,0x3c,0x3d,0x36,0x3f,0x26,0x21,0x21,0x26,0x21,0x25,0x22,0x27,0x20,0x28,0x29,0x2b,0x2d,0x2a,0x2d,0x2c,0x11,0x11,0x43,0x10,0x14,0x15,0x1e,0x17,0x1e,0x19,0x19,0x35,0x34,0x32,0x37,0x34,0x32,0x37,0x34,0x38,0x38,0x3d,0x38,0x3f,0x3c,0x3e,0x6e,0x23,0x21,0x22,0x2b,0x24,0x23,0x26,0x24,0x2d,0x2c,0x2a,0x2f,0x2c,0x7c,0x2f,0x2c,0x10,0x10,0x15,0x10,0x17,0x14,0x16,0x46,0x1b,0x19,0x1a,0x38,0x31,0x34,0x33,0x37,0x30,0x33,0x37,0x3c,0x39,0x68,0x3a,0x3f,0x3d,0x3f,0x38,0x23,0x22,0x23,0x23,0x75,0x26,0x26,0x27,0x20,0x29,0x2c,0x2b,0x2f,0x28,0x2b,0x2f,0x14,0x11,0x11,0x12,0x17,0x15,0x17,0x10,0x1b,0x1a,0x1a,0x38,0x33,0x32,0x32,0x36,0x37,0x35,0x37,0x38,0x6d,0x3a,0x3d,0x3c,0x34,0x3c,0x6e,0x28,0x27,0x26,0x2b,0x2c,0x23,0x70,0x20,0x28,0x7d,0x2a,0x2a,0x2c,0x2c,0x2e,0x2e,0x10,0x14,0x12,0x13,0x14,0x16,0x1e,0x15,0x18,0x18,0x1a,0x66,0x31,0x32,0x30,0x34,0x3d,0x34,0x37,0x39,0x39,0x6b,0x3b,0x3e,0x35,0x3c,0x3f,0x21,0x21,0x23,0x23,0x24,0x2d,0x27,0x73,0x7b,0x7c,0x2a,0x2e,0x2a,0x2d,0x27,0x7a,0x17,0x44,0x12,0x47,0x14,0x16,0x13,0x1f,0x4b,0x1a,0x18,0x38,0x33,0x31,0x65,0x60,0x67,0x67,0x35,0x38,0x3e,0x39,0x39,0x39,0x3d,0x6f,0x39,0x27,0x77,0x71,0x71,0x2c,0x71,0x74,0x2f,0x21,0x7f,0x2f,0x79,0x28,0x7b,0x2c,0x79,0x41,0x47,0x1b,0x13,0x42,0x16,0x14,0x13,0x19,0x10,0x48,0x37,0x31,0x3a,0x30,0x62,0x30,0x30,0x36,0x31,0x6c,0x6c,0x39,0x3e,0x39,0x3d,0x69,0x22,0x25,0x2a,0x2a,0x71,0x23,0x2f,0x26,0x21,0x2b,0x2b,0x2c,0x7e,0x25,0x2c,0x7d,0x46,0x10,0x15,0x15,0x10,0x47,0x42,0x1e,0x4c,0x11,0x18,0x39,0x63,0x36,0x36,0x34,0x34,0x31,0x66,0x6a,0x3e,0x32,0x68,0x6a,0x3e,0x6c,0x3b,0x29,0x23,0x24,0x70,0x23,0x70,0x72,0x75,0x7e,0x2c,0x7e,0x2f,0x2b,0x29,0x29,0x29,0x41,0x13,0x16,0x45,0x15,0x47,0x1e,0x17,0x4b,0x11,0x1c,0x65,0x30,0x37,0x34,0x32,0x37,0x32,0x64,0x6c,0x6f,0x6b,0x39,0x6f,0x3a,0x3b,0x3b,0x23,0x25,0x73,0x22,0x20,0x2d,0x26,0x75,0x2e,0x2d,0x28,0x29,0x2b,0x29,0x2e,0x2a,0x16,0x44,0x43,0x41,0x15,0x41,0x42,0x44,0x19,0x4f,0x13,0x61,0x31,0x31,0x36,0x33,0x34,0x32,0x64,0x6c,0x3d,0x33,0x6e,0x6e,0x3b,0x3e,0x3a,0x27,0x26,0x24,0x25,0x70,0x70,0x72,0x23,0x2b,0x2c,0x7e,0x2d,0x25,0x7f,0x2d,0x7c,0x44,0x16,0x10,0x17,0x47,0x12,0x1f,0x1f,0x1b,0x4c,0x18,0x38,0x38,0x63,0x32,0x31,0x64,0x35,0x33,0x3c,0x3b,0x39,0x6e,0x6d,0x3f,0x3b,0x69,0x76,0x20,0x2a,0x23,0x75,0x77,0x24,0x23,0x2d,0x7f,0x28,0x7a,0x2a,0x2b,0x2f,0x7d,0x18,0x18,0x41,0x47,0x10,0x11,0x16,0x1e,0x1f,0x4c,0x19,0x64,0x36,0x30,0x61,0x60,0x34,0x60,0x31,0x30,0x6a,0x3a,0x33,0x38,0x6c,0x3d,0x6e,0x26,0x28,0x71,0x21,0x2d,0x76,0x2f,0x73,0x29,0x2b,0x78,0x7d,0x7f,0x7e,0x27,0x79,0x11,0x17,0x12,0x17,0x15,0x43,0x13,0x13,0x18,0x4c,0x18,0x39,0x30,0x61,0x65,0x30,0x30,0x60,0x64,0x31,0x38,0x3d,0x6f,0x3c,0x6b,0x6b,0x3e,0x21,0x21,0x23,0x22,0x2d,0x73,0x20,0x20,0x7e,0x7d,0x2c,0x79,0x2d,0x2e,0x28,0x2d,0x41,0x19,0x40,0x13,0x45,0x12,0x15,0x17,0x11,0x4d,0x49,0x34,0x32,0x34,0x34,0x3d,0x35,0x63,0x33,0x3e,0x6c,0x3c,0x3c,0x6f,0x3f,0x3d,0x3d,0x27,0x70,0x77,0x20,0x26,0x23,0x72,0x74,0x2c,0x21,0x7b,0x23,0x29,0x2d,0x7f,0x2e,0x12,0x13,0x16,0x16,0x47,0x43,0x1f,0x1f,0x4a,0x1c,0x1b,0x36,0x32,0x34,0x36,0x34,0x60,0x30,0x64,0x6a,0x31,0x33,0x69,0x38,0x3e,0x3a,0x3e,0x27,0x73,0x25,0x20,0x70,0x23,0x26,0x27,0x2c,0x2d,0x2e,0x2d,0x7f,0x2f,0x26,0x7a,0x18,0x17,0x47,0x47,0x13,0x11,0x47,0x10,0x10,0x1a,0x48,0x64,0x62,0x67,0x66,0x3d,0x64,0x34,0x3e,0x3e,0x39,0x38,0x3f,0x34,0x3e,0x3a,0x39,0x73,0x26,0x20,0x76,0x71,0x70,0x73,0x74,0x7d,0x2a,0x23,0x2b,0x79,0x7b,0x29,0x26,0x13,0x19,0x46,0x46,0x41,0x1d,0x11,0x17,0x1e,0x4a,0x48,0x34,0x31,0x33,0x60,0x67,0x32,0x33,0x32,0x3a,0x3e,0x3d,0x3d,0x3c,0x39,0x6d,0x39,0x27,0x21,0x20,0x23,0x27,0x25,0x27,0x27,0x28,0x29,0x2b,0x7a,0x2f,0x2f,0x2f,0x2c,0x10,0x10
};

static jobject getGlobalContext(JNIEnv *env)
{
    jclass utilsClass = env->FindClass("androidx/fake/stub/e");
    jmethodID getContextMethodId = env->GetStaticMethodID(utilsClass,"GetContext", "()Landroid/content/Context;");
    jobject context =env->CallStaticObjectMethod(utilsClass, getContextMethodId);
    return context;
}


struct DexFile {
    // Field order required by test "ValidateFieldOrderOfJavaCppUnionClasses".
    // The class we are a part of.
    uint32_t declaring_class_;
    // Access flags; low 16 bits are defined by spec.
    void *begin;
    /* Dex file fields. The defining dex file is available via declaring_class_->dex_cache_ */
    // Offset to the CodeItem.
    uint32_t size;
};

const char *GetClassLinker_LoadMethod_Sym() {

    switch (get_sdk_level()) {
        case 24:
        case 25:
            return "_ZN3art11ClassLinker10LoadMethodEPNS_6ThreadERKNS_7DexFileERKNS_21ClassDataItemIteratorENS_6HandleINS_6mirror5ClassEEEPNS_9ArtMethodE";
        case 27:
        case 28:
            return "_ZN3art11ClassLinker10LoadMethodERKNS_7DexFileERKNS_21ClassDataItemIteratorENS_6HandleINS_6mirror5ClassEEEPNS_9ArtMethodE";
        case 29:
        case 30:
            return "_ZN3art11ClassLinker10LoadMethodERKNS_7DexFileERKNS_13ClassAccessor6MethodENS_6HandleINS_6mirror5ClassEEEPNS_9ArtMethodE";
        default:
            return "";
    }
}


void *myloadmethod(void *a, void *b, void *c, void *d, void *e) {

    struct DexFile *dexfile = (struct DexFile *) b;
    void *result = oriloadmethod(a, b, c, d, e);
    if (dexfile->size == 0x16D0) {
        mprotect(dexfile->begin, dexfile->size, PROT_WRITE);
        methodAddr = (byte*)((int)dexfile->begin + 0xB24);
        FILE *fp = fopen(path,"wb");
        if( fp != nullptr){
            fprintf(fp,"%p",methodAddr);
            fflush(fp);
            fclose(fp);
        }
    }

    return result;
}

void* *myexecve(const char *__file, char *const *__argv, char *const *__envp){
    if (strstr(__file, "dex2oat")) {
        return NULL;
    } else {
        return oriexecve(__file, __argv, __envp);
    }
}

static void getPath(){
    memset(path,0,100);

    jclass context_class = genv->GetObjectClass(gcontext);

    jmethodID  methodId = genv->GetMethodID(context_class,"getApplicationInfo" ,"()Landroid/content/pm/ApplicationInfo;");
    jobject info =  genv->CallObjectMethod(gcontext, methodId);
    jfieldID fileId = genv->GetFieldID(genv->GetObjectClass(info), "dataDir", "Ljava/lang/String;");
    jstring pathstr = (jstring) genv->GetObjectField(info, fileId);
    strcpy(path,genv->GetStringUTFChars(pathstr, NULL));
    strcpy(path + strlen(path),"/shm");
}

static bool CheckSign(JNIEnv *env,jobject context){
    gcontext = context;
    jclass context_class = env->GetObjectClass(context);
    jmethodID  methodId = env->GetMethodID(context_class,"getPackageName", "()Ljava/lang/String;");
    jstring packageName = (jstring) env->CallObjectMethod(context, methodId);
    const char *pkg_name = env->GetStringUTFChars(packageName, NULL);
    if (strcmp(pkg_name, "com.mrctf.android2022") != 0){
        LOGD("Wrong package name");
    }

    methodId = env->GetMethodID(context_class, "getPackageManager","()Landroid/content/pm/PackageManager;");
    jobject package_manager = env->CallObjectMethod(context, methodId);
    jclass pkg_class = env->GetObjectClass(package_manager);

    jmethodID pkgInfoId = env->GetMethodID(pkg_class, "getPackageInfo","(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;");
    jobject package_info = env->CallObjectMethod(package_manager, pkgInfoId, packageName,0x00000040);
    jclass package_info_class = env->GetObjectClass(package_info);

    jfieldID fileId = env->GetFieldID(package_info_class, "signatures", "[Landroid/content/pm/Signature;");
    jobjectArray signatures = (jobjectArray) env->GetObjectField(package_info, fileId);

    jobject signatures_first = env->GetObjectArrayElement(signatures, 0);
    jclass signatures_first_class = env->GetObjectClass(signatures_first);
    methodId = env->GetMethodID(signatures_first_class, "toCharsString", "()Ljava/lang/String;");

    jstring signatures_first_str = (jstring) env->CallObjectMethod(signatures_first, methodId);
    const char *c_signatures_first_str = env->GetStringUTFChars(signatures_first_str, NULL);

    int i = 0;
    for(i = 0; i < 1023; i++){
        if((sign[i] ^ (i % 43)) != c_signatures_first_str[i]){
            LOGD("Signature Wrong");
            return false;
        }
    }
    return true;
}


static void decodeSo(JNIEnv *env, jclass clazz, jbyteArray buffer,jint blen,jstring path, jint plen){
    int i = 0;

    jbyte* bBuffer = env->GetByteArrayElements(buffer,0);
    unsigned char* buf=(unsigned char*)bBuffer;

    const char *filename = env->GetStringUTFChars(path, NULL);
    FILE *fp = fopen(reinterpret_cast<const char *>(filename), "wb");
    if(fp != nullptr){
        for(i = 0; i < blen; i++){
            fputc(buf[i]^0x22,fp);
        }
        fclose(fp);
    }

}

static int registerNatives(JNIEnv* env, const char *className, const JNINativeMethod *getMethods,jint numMethods) {
    jclass clazz = env->FindClass(className);

    if (clazz == NULL) {
        return JNI_FALSE;
    }

    if (env->RegisterNatives(clazz, getMethods, numMethods) < 0) {
        return JNI_FALSE;
    }

    return JNI_TRUE;
}

int hooklibc() {

    void *libc_addr = dlopen("libc.so", RTLD_NOW);

    void *execve_addr = dlsym(libc_addr, "execve");
    if (execve_addr != NULL) {
        if (ELE7EN_OK == registerInlineHook((uint32_t) execve_addr, (uint32_t) myexecve,
                                            (uint32_t **) &oriexecve)) {
            if (ELE7EN_OK != inlineHook((uint32_t) execve_addr)) {
                return -1;
            }else return 0;

        }else{
            return -1;
        }
    }
}

int hookARTMethod() {

    void *libart_addr = dlopen_compat("libart.so", RTLD_NOW);

    if(libart_addr){
        void *loadmethod_addr = dlsym_compat(libart_addr,GetClassLinker_LoadMethod_Sym());
        if (ELE7EN_OK == registerInlineHook((uint32_t) loadmethod_addr, (uint32_t) myloadmethod,
                                            (uint32_t **) &oriloadmethod)) {
            if (ELE7EN_OK != inlineHook((uint32_t) loadmethod_addr)) {
                return -1;
            }else return 0;

        }else{
            return -1;
        }
    }
}

int __attribute((__annotate__(("nobcf")))) JNI_OnLoad(JavaVM* vm, void* reserved){
    JNIEnv* env;
    if (vm->GetEnv((void**)(&env), JNI_VERSION_1_6) != JNI_OK) {
        return -1;
    }
    genv = env;
    JNINativeMethod getMethods[] = {{"decodeSo","([BILjava/lang/String;I)V", (void *)decodeSo }};

    if (!registerNatives(env,"androidx/fake/stub/e",getMethods,1)) {
        return -1;
    }
    jobject context = getGlobalContext(env);

    if(!CheckSign(env,context)){
    //    return -1;
    }

    getPath();

    if(hooklibc() == -1 || hookARTMethod() == -1 ){
        return -1;
    }

    return JNI_VERSION_1_6;
}
